enum Code {
    //授权失败
    const AUTH_FAILED = -99
    // 登陆失败
    const LOGIN_FAILED = -100
    // 用户已经存在
    const USER_EXISTS = -101
    // 登陆过期需要重新登陆
    const LOGIN_EXPIRED = -102
    // 匿名无权
    const ANNOYMOUS_DENY = -103
    // 没有找到用户
    const USER_NOT_FOUND = -104
    // 验证失败
    const VERIFY_FAILED = -105
    // 分派房间id失败
    const ROOMID_FAILED = -106
    // 正在等待好友通过
    const FRIEND_WAIT = -107
    // 不满足条件
    const REQUIREMENT_FAILED = -108
    // 满员
    const ROOM_FULLED = -109
    //房间信息过期
    const ROOM_NEED_UPDATE = -88
    // 房间过期
    const ROOM_EXPIRED = -110
    // 用户已经在房间内
    const ROOM_USER_EXISTS = -111
    // 宝宝列表已满
    const BAG_FULLED = -112
    // 道具不足
    const NEED_ITEMS = -113
    // 正在等待自己通过
    const FRIEND_APPLY = -114
    // 已经是好友
    const FRIEND_DONE = -115
    // 已经是好友
    const SPE_LIMIT = -116
    // 已经领取
    const PICKED = -117
    // 条件未满足
    const REQUIRED_LOST = -118
    // 用户不在线
    const USER_OFFLINE = -119
    // 用户已经组队
    const USER_INTEAM = -120
    // 回答错误
    const ANSWER_WRONG = -121
    // 是自己
    const CANNOT_BE_SELF = -122
    // 必须是好友
    const MUST_FRIEND = -127
    //不是首次分享
    const ISSHARED = -134
    //企业没钱
    const NO_MONEY = -136
    //超过提现次数
    const EXCEED_COUNT = -137
    //低于最低限额
    const LESS_MONEY = -138
    //等级上限
    const LEVEL_MAX = -140
    //道具上限
    const ITEM_MAX = -141
    //道具低于最低限制
    const ITEM_LESS = -142
    //未找到相关信息
    const NOT_FOUND = -10086
    //已经点过赞
    const HAS_LIKE = -521
    //代金券不足
    const NEED_COUPON = -170
    //金额不足
    const NEED_MONEY = -171
    //积分不足
    const NEED_INTEGRAL = -172
    //需要填写地址
    const NEED_ADDRESS = -173
    //尚未设置地址
    const NONE_ADDRESS = -174
    //不可购买
    const CANT_BUG = -175
    //未达到排名要求
    const RANK_NOT_MEET = 150
    //未达到积分要求
    const INTEGRAL_NOT_MEET = 151
    //已经拥有了，不能重复购买
    const ALREADY_GOT = 152
    //已经签到了
    const HAS_SIGNIN = -144
    //还未起飞,用户没有当前城市
    const NO_CURRENTCITY = -145

    const UNKNOWN = -1000
    // 遇到了未处理的异常
    const EXCEPTION = -999
    // 没有找到路由
    const ROUTER_NOT_FOUND = -998
    // 上下文丢失
    const CONTEXT_LOST = -997
    // 恢复模型失败
    const MODEL_ERROR = -996
    // 参数不符合要求
    const PARAMETER_NOT_MATCH = -995
    // 需要登陆
    const NEED_AUTH = -994
    // 参数类型错误
    const TYPE_MISMATCH = -993
    // 文件系统失败
    const FILESYSTEM_FAILED = -992
    // 文件不存在
    const FILE_NOT_FOUND = -991
    // 代码不符合标准架构
    const ARCHITECT_DISMATCH = -990
    // 没有找到服务器
    const SERVER_NOT_FOUND = -989
    // 长度超过限制
    const LENGTH_OVERFLOW = -988
    // 目标对象没有找到
    const TARGET_NOT_FOUND = -987
    // 没有权限
    const PERMISSIO_FAILED = -986
    // 等待实现
    const WAIT_IMPLEMENTION = -985
    // 没有找到动作
    const ACTION_NOT_FOUND = -984
    // 已经存在
    const TARGET_EXISTS = -983
    // 状态错误
    const STATE_FAILED = -982
    // 上传失败
    const UPLOAD_FAILED = -981
    // 有敏感词
    const MASK_WORD = -980
    // 验证码匹配失败
    const PASS_FAILED = -978
    // 数据溢出
    const OVERFLOW = -977
    // 授权过期
    const AUTH_EXPIRED = -976
    // 签名错误
    const SIGNATURE_ERROR = -975
    //微信请求失败
    const WX_REQUEST_ERR = -6
    // 第三方出错
    const THIRD_FAILED = -5
    // 多端登陆
    const MULTIDEVICE = -4
    // 高频调用被拒绝（之前的访问还没有结束) high frequency deny
    const HFDENY = -3
    // 超时
    const TIMEOUT = -2
    // 一般失败
    const FAILED = -1
    // 成功
    const OK = 0
    // 延迟响应
    const DELAY_RESPOND = 10000
    // rest访问需要重新启动监听
    const REST_NEED_RELISTEN = 10001

    // rest访问需要重新启动监听
    const  NO_DB_ROW  =   11001  //没有对应的数据库行
    const  NO_CFG_ROW =   11002  //没有对应的配置表行
}

enum RentItem {
    //车
    const CAR = 1
    //照相机
    const CAMERA = 2
    //医药箱
    const MEDICALBOX = 3
}

enum SystemGift {
     //用户道具(金币，积分,飞机票)
    const  USERITEM = 1
    //特产
    const  SPECIALITY = 2
    //明信片
    const  POSTCARD = 3
    //体验卡(豪华自驾车,舒适自驾车,经济自驾车,单反相机,高级单反相机,医药箱)
    const  RENTITEM = 4

}

//该Base类会在实际中作为所有api的基类
class Base{
    prop client _timestamp:number
    prop client _app:App
    prop action:string
    prop code:number//服务器返回的状态码
    prop server uid:string
    prop server _sid:string
    prop server ctx:Context
    prop requireFileds:string[]
    prop client reqFields:string[]
    prop server resFields:string[]

    func client get app() {
        if (!this._app) {
            this._app = getApp();
        }
        return this._app;
    }

    func client fetch() {
        return new Promise((resolve, reject) => {
            wx.request({
                url: Base.SRV,
                data: this.reqData,
                success: res => {
                  this.parse(res.data.data);
                  this.code = res.data.code;
                  if (this.code != Code.OK) {
                      console.log('fetch got an error code',this.code);
                      let sheets = require('./sheets.js')
                      let error = sheets.Error.Get(this.code)
                      if (error && error.message) {
                        wx.showToast({
                          title: error.message,
                          icon: 'none'
                        })
                      }
                      reject(this.code);
                  }
                  else {
                      resolve(this);
                  }
                },
                fail: err => {
                    this.error(err)
                    reject(Code.WX_REQUEST_ERR);
                }
              })
        })
    }

    func server submit() {
        if (this._submited) {
            return;
        }
        let tmp = {};
        tmp.action = this.action;
        this.resFields.forEach(k => {
           tmp[k] = this[k]
        });

        this.ctx.body = {data: tmp, code: this.code};
        this._submited = true;
    }

    func server static async checkLogin(res) {
        if (!res.sid) {
            res.code = Code.USER_NOT_FOUND;
            res.submit();
            return;
        }

        let ui = await res.ctx.service.publicService.userService.findUserBySid(res.sid);
        if(!ui){
            res.ctx.logger.info("用户不存在");
            res.code = Code.USER_NOT_FOUND;
            res.submit();
        }
        else {
            res.ui = ui;
        }
        return res;
    }

    func client get reqData() {
        let tmp = {};
        let sid = Base.GetSID();
        if (sid)
            tmp.sid = sid;
        let uid = Base.GetUID();
        if (uid)
            tmp.uid = uid;
        this.reqFields.forEach(k => {
            tmp[k] = this[k] === null ? '' : this[k];
        });
        tmp.appName = Base.APP_NAME;
        tmp.action = this.action;
        return tmp;
    }

    func parse(data, serverSide = false) {
        Object.assign(this, data);

        for (let f in this.requireFileds) {
            if (!this[f]) {
                break;
                if (serverSide)
                    ctx.body = {code: Code.PARAMETER_NOT_MATCH}
                else {
                    throw new Error('参数不全')
                }
            }
        }
    }

    func client error(err) {

    }

    func client static GetUID() {
        if (!Base.UID) {
            Base.UID = wx.getStorageSync('uid');
        }
        return Base.UID;
    }

    func client static GetSID() {
        if (!Base.SID) {
            Base.SID = wx.getStorageSync('sid');
        }
        return Base.SID;
    }
    
    func client static Start(appName, url, shareUid) {
        if(shareUid)
            this.shareUid = shareUid;
        return new Promise((resolve,reject) => {
            let app = getApp();
            if (this.LOGINED) {
                //已经有用户数据
                resolve();
            }
            else {
                this.DoStart(appName, url).then(resolve).catch(reject);
            }
        });
    }

    func client static DoStart(appName, url) {
        //定义一些静态变量
        this.SID = '';
        this.UID = '';
        this.APP_NAME = appName;
        this.SRV = url || 'https://h5.ddz2018.com/';//https服务器链接
        this.AUTHED = false;

        //start
        return new Promise(resolve => {
            wx.checkSession({
                success: () => {
                    if (Base.GetSID() || Base.GetUID()){
                        this.AUTHED = true;
                        this.UserLogin(resolve)
                    }
                    else {
                        wx.login({
                            success: res => {
                                this.AUTHED = false;
                                this.UserAuth(res.code, resolve);
                            }
                        })
                    }
                },
                fail: res => {
                    wx.login({
                        success: res => {
                            this.AUTHED = false;
                            this.UserAuth(res.code, resolve);
                        }
                    })
                }
            });
        });

    }

    func client static UserAuth(code, suc) {
        let req = new Base();
        req.action = 'weChat.auth';
        req.reqFields = ['payload'];

        //set data
        req.payload = {code};
        req.fetch().then( res => {
            this.UID = res.uid;
            wx.setStorageSync('uid', this.UID);
            this.UserLogin(suc);
        });
    }

    func client static UserLogin(suc) {
        let req = new Base();
        req.action = 'user.login';
        req.reqFields = [ 'info'];
        if (this.shareUid) {
            req.reqFields.push('shareUid');
            req.shareUid = this.shareUid;
        }

        //wx login
        wx.getUserInfo({
            success: info =>{
                let app = getApp();

                //fetch srv
                req.info = info.userInfo;
                req.fetch().then(()=>{
                    this.AUTHED = true;
                    this.LOGINED = true;
                    this.shareUid = null;

                    app.globalData.userInfo = req.info;
                    this.SID = req.sid;
                    this._timestampD = Date.now()/1000  - req.timestamp;
                    wx.setStorageSync('sid', this.SID);
                    suc(req);
                });
            }
        });

    }

    func client static get servertime() {
        return ( Date.now()/1000-this._timestampD) * 1000
    }


}

class WsSend extends Base{
    //此类仅用于标记子类是websocket客户端数据协议---发送结构
}
class WsReceive extends Base{
    //此类用于标记子类是websocket客户端数据协议---接收结构
    func server submit() {
        let tmp = {};
        tmp.action = this.action;
        this.resFields.forEach(k => {
            tmp[k] = this[k]
        });

        this.ctx.socket.emit(this.action, {data: tmp, code: this.code});
    }
}


class Ws {
    func client static init(wss) {
        if (this.IO) {
            return;
        }
        //初始化websocket
        this.WSS = wss = wss || `wss://h5.ddz2018.com/${Base.APP_NAME}`;//websocket服务器链接
        this.IO = require('./libs/io.js')(wss + `?_sid=${Base.GetSID()}&uid=${Base.GetUID()}&appName=${Base.APP_NAME}`);//query里直接用sid连接不上，必须用_sid，不知道为啥
        this._listenings = new Map();

        return new Promise(resolve => {
            this.IO.on('connect', () => {
                console.log('socket connected')
                resolve();
            });

            this.IO.on('disconnect', msg => {
                console.log('socket disconnected', msg);
            });

            this.IO.on('disconnecting', () => {
                console.log('socket disconnecting');
            });

            this.IO.on('error', () => {
                console.log('socket error');
            });
        });
    }

    func client static listen(wsReceiveCls, cb, ctx) {
        if (!this._listenings) {
            console.error('ws has not inited');
            return;
        }
        let action = wsReceiveCls.name.toLowerCase();
        if (!this._listenings.has(action)) {
            this._listenings.set(action, new wsReceiveCls);
        }

        let listener = this._listenings.get(action);
        listener.cbx = {cb, ctx};

        this.IO.on(action, this._onReceive.bind(this));
    }

    func client static unlisten(wsReceiveCls, cb, ctx) {
        if (!this._listenings) {
            console.error('ws has not inited');
            return;
        }
        let action = wsReceiveCls.name.toLowerCase();
        if (this._listenings.has(action)) {
            let listener = this._listenings.get(action);
            listener.cbx = null;
        }
    }

    func client static _onReceive(res) {
        let data = res.data
        let action = data.action;
        if (!this._listenings.has(action))
            return;
        let listener = this._listenings.get(action);

        listener.parse(data);
        listener.code = res.code;
        let cbx = listener.cbx;
        cbx && cbx.ctx ? cbx.cb.call(cbx.ctx, listener) : cbx.cb(listener);

    }

    func client static send(wsSend) {
        this.IO.emit(wsSend.action, wsSend.reqData);
    }

    func client static close() {
        if(this.IO) {
            this.IO.close();
            wx.closeWebsocket();
            this.IO = null;
        }

    }

}


class Http {

    func client static init() {
        this.LS_IDLE = 'IDLE';
        this.LS_BUSY = 'BUSY';
        this.LS_SUC = 'SUC';
        this.LOOP_INTERVAL = 300;
        this._listenings = this._listenings || new Map();
    }

    func client static listen(apiCls, cb, ctx, interval = 300, preFetch = null) {
        if (!this._listenings) {
            console.error('Http loop has not inited');
            return;
        }
        let action = apiCls.name.toLowerCase();
        if (!this._listenings.has(action)) {
            this._listenings.set(action, new apiCls);
        }

        let listener = this._listenings.get(action);
        listener.cbx = {cb, ctx, interval, status: this.LS_IDLE, passedTm: 0, preFetch: preFetch};


        //start loop
        this.loopListen();
    }

    func client static unlisten(apiCls, cb, ctx) {
        if (!this._listenings) {
            console.error('Http loop has not inited');
            return;
        }
        let action = apiCls.name.toLowerCase();
        if (this._listenings.has(action)) {
            let listener = this._listenings.get(action);
            listener.cbx = null;
            this._listenings.delete(action);

            if (!this._listenings.size) {
                this.clearLoop();
            }
        }
    }

    func client static loopListen() {
        if (this._listenHdl) {
            return;
        }
        this._listenHdl = setInterval(() => {
            this._listenings.forEach(lsnr => {
                let cfg = lsnr.cbx;
                cfg.passedTm += this.LOOP_INTERVAL;
                if (cfg.passedTm >= cfg.interval) {

                    cfg.passedTm = 0;
                    switch(cfg.status) {
                        case this.LS_IDLE:
                            cfg.status = this.LS_BUSY;
                            if (cfg.preFetch) {
                                //fetch之前，可以通过此回调，对lsnr请求字段付值
                                cfg.ctx ? cfg.preFetch.call(cfg.ctx, lsnr) : cfg.preFetch(lsnr);
                            }
                            lsnr.fetch().then(()=>{
                                cfg.status = this.LS_SUC;
                            }).catch(errCode => {
                                cfg.ctx ? cfg.cb.call(cfg.ctx, lsnr, errCode) : cfg.cb(lsnr, errCode);
                            });
                            break;
                        case this.LS_SUC:
                            cfg.status = this.LS_BUSY;

                            cfg.ctx ? cfg.cb.call(cfg.ctx, lsnr) : cfg.cb(lsnr);
                            cfg.status = this.LS_IDLE;
                            break;
                        case this.LS_BUSY:
                            //wait to be suc
                            break;
                    }
                }
            })

        }, this.LOOP_INTERVAL);
    }

    func client static clearLoop() {
        if (this._listenHdl) {
            clearInterval(this._listenHdr);
            this._listenHdl = null;
        }
    }
}

